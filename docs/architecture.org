* Event Loop
The basic structure of the app is just this:

#+BEGIN_SRC pseudocode
while(true){
  in = consume_input();
  new_state = process_input(in,state); // process_input is a state machine
  render_output(new_state);
  state = new_state;
}
#+END_SRC

* Command Parsing
The UI is modal, so parsing contextual commands is the main feature.

Inputs are classified according to type:

#+BEGIN_SRC js
let input_table=/* Type: input_char */
{
  mult0:'123456789',
  multN:'0123456789',
  verb:'cdvy',
  modifier:'ai',
  text_object:'0^${}()[]<>`"\'bBeEwWG',
  motion:'hjkl',
  search_char:'fFtT',
  edit:'aAiIoOpPrxX',
  undo:'u',
  repeat:',.',
};
#+END_SRC

The following type-combinations make a valid command:

- =mult? verb mult? modifier? text_object= operates on a range defined by a text object
- =mult? verb mult? search_char char= operates on the range (starting point, =char=)
- =mult? verb mult? motion= operates on a range defined by (starting point, =motion=)
- =mult? text_object= moves the cursor
- =mult? motion= moves the cursor
- =mult? search_char char= moves the cursor
- =mult? edit= cut/paste =mult?= times
- =mult? edit char* ESC= edit the document chars =mult?= times
- =mult? undo= undo as many times as specified by =mult?=
- =mult? repeat= repeat as many times as specified by =mult?=

** State Machine
Another way to translate typed commands into functions is through a state machine.
The letter x is used to indicate disallowed states.

| State\Input | mult0          | multN          | verb                      | modifier     | text_object | motion      |
|-------------+----------------+----------------+---------------------------+--------------+-------------+-------------|
| initial     | multN          | multN          | to(mult0,verb)            | x            | goto        | goto        |
| mult0       | any            | any            | to(multN,verb)            | x            | goto        | goto        |
| multN       | x              | any            | to(verb,mult0)            | x            | goto        | goto        |
| verb        | to(multN,verb) | to(multN,verb) | doit(double_verb_if_same) | obj\{vert}mo | doit(range) | doit(range) |
| modifier    | x              | x              | x                         | x            | x           | x           |
| text_object | x              | x              | x                         | x            | x           | x           |
| motion      | x              | x              | x                         | x            | x           | x           |

- [[http://parlab.eecs.berkeley.edu/wiki/_media/patterns/finitestatemachine.pdf][Finite State Machine pattern (PDF)]]
- [[https://gamedevelopment.tutsplus.com/tutorials/finite-state-machines-theory-and-implementation--gamedev-11867][State Machines for Games, in AS3]]
- [[https://github.com/Olical/StateMachine][State Machine library in JavaScript]]

* Keyboard Input
Wim is keyboard-centric and has to handle both key /sequences/ and key /chords/.
This can get quite complex if you let it.

For example, say you create a keyboard shortcut =Ctrl a b= where 3 keys are held simultaneously.
But you might also want a sequence =a b= in which first a is pressed, then b.
A fast touch-typist may not fully release one key before pressing another, so Wim might register that both the =Ctrl a b= chord and the =a b= sequence have occurred.

Wim must do one of:
1. prioritize based on an implicit global rule (e.g. evaluate chords before sequences)
2. prioritize based on a user-defined setting
3. disallow conflicts (e.g. throw an exception if user tries to load a config with conflicts)
4. ask the user to resolve conflicts manually

Wim currently uses an implicit global rule because it's the simplest to implement.

Wim also permits cancellation of an in-progress or multi-part command.
This "cancel anything" command is bound to =Ctrl g= by default.

Key sequences are =push=ed to an array; chords reside in a Set.

** Keyboard Commands
When in normal mode, Wim parses keyboard input [[https://en.wikipedia.org/wiki/Eager_evaluation][eagerly]], attempting to match keystrokes with predefined commands.
When it finds a match, it executes that command.
Otherwise it displays an error message indicating which command failed to match.

** =KeyboardEvent.code=
These codes map to physical keyboard buttons.
"KeyA" does not distinguish between upper- and lower-case =A=.

** =KeyboardEvent.key=
This can be a single-letter string such as "A" or a string representing the name of the key such as "Escape".
MacOS allows users to enter combining characters, such as accented vowels, but as far as Chrome's KeyboardEvent interface is concerned, these are all "Dead" keys.
If we want to accept characters beyond the default set we have to handle them ourselves.

** =KeyboardEvent.timestamp=
Milliseconds since program started.
Truncated to int.

** =KeyboardEvent.type=
1 for "keydown", 0 for "keyup"

** Modifier keys
Wim converts =KeyboardEvent= modifier key properties ("altKey", "ctrlKey", "metaKey", and "shiftKey") into a 4-bit integer (number from 0 to 15).
Any combination of modifier keys can be represented as a single number:

| =alt= / =option= | =ctrl= | =meta= / =command= | =shfit= | =value= |
|------------------+--------+--------------------+---------+---------|
|                0 |      0 |                  0 |       0 |       0 |
|                0 |      0 |                  0 |       1 |       1 |
|                0 |      0 |                  1 |       0 |       2 |
|                0 |      0 |                  1 |       1 |       3 |
|                0 |      1 |                  0 |       0 |       4 |
|                0 |      1 |                  0 |       1 |       5 |
|                0 |      1 |                  1 |       0 |       6 |
|                0 |      1 |                  1 |       1 |       7 |
|                1 |      0 |                  0 |       0 |       8 |
|                1 |      0 |                  0 |       1 |       9 |
|                1 |      0 |                  1 |       0 |      10 |
|                1 |      0 |                  1 |       1 |      11 |
|                1 |      1 |                  0 |       0 |      12 |
|                1 |      1 |                  0 |       1 |      13 |
|                1 |      1 |                  1 |       0 |      14 |
|                1 |      1 |                  1 |       1 |      15 |

** When =RawKeys= contains something interesting, do something
Within normal mode, the user may:

1. be in the middle of typing a valid command sequence
2. finish typing a valid command sequence
3. want to cancel a command sequence
4. enter an invalid command sequence

Within insert mode, the user may:

1. add characters
2. remove characters
3. want to leave insert mode (e.g. "Escape" key)
4. move caret with arrow keys
