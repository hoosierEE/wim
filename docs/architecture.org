* Event Loop
In principle Wim works like this pseudocode:

#+BEGIN_SRC pseudocode
while(true){
  in = consume_input();
  new_state = process_input(in,state); // process_input is a state machine
  render_output(new_state);
  state = new_state;
}
#+END_SRC

But since Wim uses =addEventListener= to consume keyboard events, the =while= loop is implicit.

In reality, Wim responds to each =KeyboardEvent= by placing a callback to the =process_input= and =render_output= functions in its event loop queue, through the use of =requestAnimationFrame=.

* Command Parsing
Inputs are classified according to type:

#+BEGIN_SRC js
let input_table=/* {Type:[Char]} */
{
  mult0:'123456789',
  multN:'0123456789',
  verb:'cdvy',
  modifier:'ai',
  text_object:'0^${}()[]<>`"\'bBeEwWG',
  motion:'hjkl',
  search_char:'fFtT',
  edit:'aAiIoOpPrxX',
  undo:'u',
  repeat:',.',
};
#+END_SRC

Note that some chars belong to more than 1 type, for example =0= is in =multN= as well as =text_object=.
Parsing a command depends on past state and can not be determined from the character sequence alone.

The following type combinations make a valid command (=?= means optional):
- =mult? verb mult? modifier? text_object= operates on a range defined by a text object
- =mult? verb mult? search_char char= operates on the range (starting point, =char=)
- =mult? verb mult? motion= operates on a range defined by (starting point, =motion=)
- =mult? text_object= moves the cursor
- =mult? motion= moves the cursor
- =mult? search_char char= moves the cursor
- =mult? edit= cut/paste =mult?= times
- =mult? edit char* ESC= edit the document chars =mult?= times
- =mult? undo= undo as many times as specified by =mult?=
- =mult? repeat= repeat as many times as specified by =mult?=

* State Transition Tables
Another way to represent valid commands is with a state transition table.

- [[http://parlab.eecs.berkeley.edu/wiki/_media/patterns/finitestatemachine.pdf][Finite State Machine pattern (PDF)]]
- [[https://gamedevelopment.tutsplus.com/tutorials/finite-state-machines-theory-and-implementation--gamedev-11867][State Machines for Games, in AS3]]
- [[https://github.com/Olical/StateMachine][State Machine library in JavaScript]]

* Keyboard Input
Wim is keyboard-centric and has to handle both key /sequences/ and key /chords/.
This can get quite complex if you let it.

For example, say you create a keyboard shortcut =Ctrl a b= where 3 keys are held simultaneously.
But you might also want a sequence =a b= in which first a is pressed, then b.
A fast touch-typist may not fully release one key before pressing another, so Wim might register that both the =Ctrl a b= chord and the =a b= sequence have occurred.

Wim must do one of:
1. prioritize based on an implicit global rule (e.g. evaluate chords before sequences)
2. prioritize based on a user-defined setting
3. disallow conflicts (e.g. throw an exception if user tries to load a config with conflicts)
4. ask the user to resolve conflicts manually

Wim currently uses an implicit global rule (chords take priority over sequences) because it's the simplest to implement.

Wim also permits cancellation of an in-progress or multi-part command.
The "cancel anything" command is bound to =Ctrl g= by default.

Currently-pressed chords are stored in a =Set= until the keys are released.
Recently-pressed keys are also stored in a fixed-length FIFO =Array=.

** Individual Keys
In normal mode, Wim parses keyboard input [[https://en.wikipedia.org/wiki/Eager_evaluation][eagerly]], attempting to match keystrokes with predefined commands.

*** KeyboardEvent.code : =String=
These codes map to physical keyboard buttons.
"KeyA" does not distinguish between upper- and lower-case =A=.

*** KeyboardEvent.key : =String=
This can be a single-letter string such as "A" or a string representing the name of the key such as "Escape".
MacOS allows users to enter combining characters, such as accented vowels, but as far as Chrome's KeyboardEvent interface is concerned, these are all "Dead" keys.
If we want to accept characters beyond the default set we have to handle them ourselves.

*** KeyboardEvent.timestamp : =u64=
Milliseconds since program started.

*** KeyboardEvent.type : =u1=
1 for "keydown", 0 for "keyup".

** Modifier keys : =u4=

| =alt= / =option= | =ctrl= | =meta= / =command= | =shfit= | =value= |
|------------------+--------+--------------------+---------+---------|
|                0 |      0 |                  0 |       0 |       0 |
|                0 |      0 |                  0 |       1 |       1 |
|                0 |      0 |                  1 |       0 |       2 |
|                0 |      0 |                  1 |       1 |       3 |
|                0 |      1 |                  0 |       0 |       4 |
|                0 |      1 |                  0 |       1 |       5 |
|                0 |      1 |                  1 |       0 |       6 |
|                0 |      1 |                  1 |       1 |       7 |
|                1 |      0 |                  0 |       0 |       8 |
|                1 |      0 |                  0 |       1 |       9 |
|                1 |      0 |                  1 |       0 |      10 |
|                1 |      0 |                  1 |       1 |      11 |
|                1 |      1 |                  0 |       0 |      12 |
|                1 |      1 |                  0 |       1 |      13 |
|                1 |      1 |                  1 |       0 |      14 |
|                1 |      1 |                  1 |       1 |      15 |

** When =RawKeys= contains something interesting, do something
Within normal mode, the user may:
1. begin typing a command sequence
2. be in the middle of typing a valid command sequence
3. finish typing a valid command sequence
4. cancel a command sequence
5. enter an invalid command sequence

Within insert mode, the user may:
1. add characters
2. remove characters
3. leave insert mode (e.g. "Escape" key)
4. move caret with arrow keys
